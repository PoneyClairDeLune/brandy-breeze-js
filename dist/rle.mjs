var emitSingleByte=byte=>{let buffer=new Uint8Array(1);return buffer[0]=byte,buffer};var encodeWindow=255,RLEEncoder=class{#length=4;get length(){return this.#length}constructor(length=4){if(length>255||length<1)throw new RangeError("Invalid length");this.#length=length}encode(source){let length=this.#length,maxWindow=encodeWindow+length,reader=source.getReader(),newController,newStream=new ReadableStream({start:controller=>{newController=controller}});return(async()=>{let undone=!0,lastByte=0,sameCount=0,totalOffset=0;for(;undone;){let{done,value}=await reader.read();if(undone=!done,!(value==null||value==null)){if(value.constructor!=Uint8Array&&value.constructor!=Uint8ClampedArray)throw new Error("Invalid input source");if(undone)for(let i=0;i<value.length;i++){let e=value[i];lastByte==e?(sameCount++,sameCount<=length?newController.enqueue(emitSingleByte(e)):sameCount<maxWindow||(newController.enqueue(emitSingleByte(sameCount-length)),sameCount=0)):(sameCount>=length&&newController.enqueue(emitSingleByte(sameCount-length)),lastByte=e,sameCount=1,newController.enqueue(emitSingleByte(e))),totalOffset++}sameCount>=length&&newController.enqueue(emitSingleByte(sameCount-length))}}newController.close(),reader.releaseLock()})(),newStream}};console.error(`RLE Codec Util
`);switch(Deno.args[0]){case"help":{console.info(`c <length> <file>    Encode file in RLE.
d <length> <file>    Decode file from RLE.

The length value must be the exact same!`);break}case"c":{let length=parseInt(Deno.args[1]),fsFile=await Deno.open(Deno.args[2],{read:!0,create:!1}),encoder=new RLEEncoder(length),fsTarget=await Deno.open(`${Deno.args[2]}.rle`,{read:!0,write:!0,createNew:!0});await encoder.encode(fsFile.readable).pipeTo(fsTarget.writable);break}case"d":{let length=parseInt(Deno.args[1]),fsFile=await Deno.open(Deno.args[2],{read:!0,create:!1}),fsTarget=await Deno.open(`${Deno.args[2]}.bak`,{read:!0,write:!0,createNew:!0});break}default:console.error("Invalid arguments.")}
//# sourceMappingURL=rle.mjs.map
